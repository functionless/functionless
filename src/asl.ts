import { Construct } from "constructs";
import { aws_iam, aws_stepfunctions } from "aws-cdk-lib";

import { assertNever } from "./assert";
import {
  CallExpr,
  Expr,
  FunctionExpr,
  isLiteralExpr,
  isReferenceExpr,
  isExpr,
} from "./expression";
import {
  BlockStmt,
  ForInStmt,
  ForOfStmt,
  IfStmt,
  isStmt,
  Stmt,
} from "./statement";
import { findFunction, lookupIdentifier } from "./util";
import { FunctionDecl } from "./declaration";
import { FunctionlessNode } from "./node";
import { JsonPath } from "aws-cdk-lib/aws-stepfunctions";

export function isASL(a: any): a is ASL {
  return (a as ASL | undefined)?.kind === ASL.ContextName;
}

export interface StateMachine<S extends States> {
  Version?: "1.0";
  Comment?: string;
  TimeoutSeconds?: number;
  StartAt: keyof S;
  States: S;
}
export interface States {
  [stateName: string]: State;
}
export type State =
  | Succeed
  | Fail
  | Choice
  | Task
  | Pass
  | MapTask
  | ParallelTask;
export type TerminalState = Succeed | Fail | Extract<State, { End: true }>;

export interface Succeed {
  Type: "Succeed";
  Comment?: string;
  InputPath?: string;
  OutputPath?: string;
}

export interface Fail {
  Type: "Fail";
  Comment?: string;
  Error: string;
}

export interface TaskParameters {
  [key: string]: any;
}

export interface Nextable {
  End?: true;
  Next?: string;
}

export interface Pass {
  Comment?: string;
  Type: "Pass";
  InputPath?: string;
  OutputPath?: string;
  ResultPath?: string;
  Parameters?: TaskParameters;
  Next: string;
}

export interface Choice {
  Type: "Choice";
  Comment?: string;
  InputPath?: string;
  OutputPath?: string;
  Choices: Branch[];
  Default?: string;
}

export interface Branch extends Condition {
  Next: string;
}

export interface Condition {
  Variable?: string;
  Not?: Condition;
  And?: Condition[];
  Or?: Condition[];
  BooleanEquals?: string;
  BooleanEqualsPath?: string;
  IsBoolean?: boolean;
  IsNull?: boolean;
  IsNumeric?: boolean;
  IsPresent?: boolean;
  IsString?: boolean;
  IsTimestamp?: boolean;
  NumericEquals?: number;
  NumericEqualsPath?: string;
  NumericGreaterThan?: number;
  NumericGreaterThanPath?: string;
  NumericGreaterThanEquals?: number;
  NumericGreaterThanEqualsPath?: string;
  NumericLessThan?: number;
  NumericLessThanPath?: string;
  NumericLessThanEquals?: number;
  NumericLessThanEqualsPath?: string;
  StringEquals?: string;
  StringEqualsPath?: string;
  StringGreaterThan?: string;
  StringGreaterThanPath?: string;
  StringGreaterThanEquals?: string;
  StringGreaterThanEqualsPath?: string;
  StringLessThan?: string;
  StringLessThanPath?: string;
  StringLessThanEquals?: string;
  StringLessThanEqualsPath?: string;
  StringMatches?: string;
  TimestampEquals?: string;
  TimestampEqualsPath?: string;
  TimestampGreaterThan?: string;
  TimestampGreaterThanPath?: string;
  TimestampGreaterThanEquals?: string;
  TimestampGreaterThanEqualsPath?: string;
  TimestampLessThan?: string;
  TimestampLessThanPath?: string;
  TimestampLessThanEquals?: string;
  TimestampLessThanEqualsPath?: string;
}

export interface Retry {
  ErrorEquals: string[];
  IntervalSeconds?: number;
  MaxAttempts?: number;
  BackoffRate?: number;
}

export interface Catch {
  ErrorEquals: string[];
  ResultPath?: string;
  Next: string;
}

export type BaseTask = Nextable & {
  Comment?: string;
  InputPath?: string;
  OutputPath?: string;
  Parameters?: TaskParameters;
  ResultSelector?: string;
  ResultPath?: string;
  Retry?: Retry[];
  Catch?: Catch[];
};

export type Task = BaseTask & {
  Type: "Task";
  Resource: string;
};

export type MapTask = BaseTask & {
  Type: "Map";
  Iterator: States;
};

export type ParallelTask = BaseTask & {
  Type: "Parallel";
  Iterator: States;
};

/**
 * Amazon States Language (ASL) Generator.
 */
export class ASL {
  static readonly ContextName = "Amazon States Language";

  readonly kind = ASL.ContextName;

  /**
   * Maps a {@link Stmt} to a unique State name. This is generated by passing over
   * the AST and assigning each state a unique name. These names are then used to
   * resolve state transitions.
   */
  readonly stateTransitions: Map<Stmt, string>;
  readonly returnTransitions: Map<FunctionDecl | FunctionExpr, string>;
  readonly throwTransitions: Map<FunctionDecl | FunctionExpr, string>;

  readonly definition: StateMachine<States>;

  constructor(
    readonly scope: Construct,
    readonly role: aws_iam.IRole,
    readonly decl: FunctionDecl
  ) {
    let i = 0;
    const nextName = () => `State${(i += 1)}`;
    this.stateTransitions = new Map<Stmt, string>(bind(decl.body));
    this.returnTransitions = new Map();
    this.throwTransitions = new Map();

    const states = this.execute(this.decl.body);

    const start = this.getStateName(this.decl.body.statements[0]);

    this.definition = {
      StartAt: start,
      States: {
        ...states,
        Success: {
          Type: "Succeed",
        },
        Throw: {
          Type: "Fail",
          Error: "TODO",
        },
      },
    };

    function bind(stmt: Stmt | undefined): [Stmt, string][] {
      if (stmt === undefined) {
        return [];
      } else if (stmt.kind === "BlockStmt") {
        return stmt.statements.reduce(
          (arr: [Stmt, string][], stmt) => arr.concat(bind(stmt)),
          []
        );
      } else if (stmt.kind === "IfStmt") {
        return [[stmt, nextName()], ...bind(stmt.then), ...bind(stmt._else)];
      } else if (stmt.kind === "ExprStmt") {
        if (stmt.expr.kind === "FunctionExpr") {
          [[stmt, nextName()], ...bind(stmt.expr.body)];
        }
      }
      return [[stmt, nextName()]];
    }
  }

  public execute(stmt: Stmt): States {
    if (stmt.kind === "BlockStmt") {
      return stmt.statements.reduce((states: States, s, i) => {
        if (i < stmt.statements.length - 1) {
          return {
            ...states,
            ...this.execute(s),
          };
        } else {
          return {
            ...states,
            ...this.execute(s),
          };
        }
      }, {});
    } else if (stmt.kind === "BreakStmt") {
      return {
        [this.getStateName(stmt)]: {
          Type: "Pass",
          Next: this.next(findLoop(stmt)),
        },
      };
      function findLoop(
        node: FunctionlessNode | undefined
      ): ForOfStmt | ForInStmt {
        if (node === undefined) {
          throw new Error(`Stack Underflow`);
        }
        if (node.kind === "ForOfStmt" || node.kind === "ForInStmt") {
          return node;
        } else {
          return findLoop(node.parent);
        }
      }
    } else if (stmt.kind === "ExprStmt") {
    } else if (stmt.kind === "ForInStmt") {
      throw new Error(`for-in is no supported in Amazon States Language`);
    } else if (stmt.kind === "ForOfStmt") {
      return {
        [this.getStateName(stmt)]: {
          Type: "Map",
          InputPath: this.evalJsonPath(stmt.expr),
          Next: this.next(stmt),
          Iterator: this.execute(stmt.body),
        },
      };
    } else if (stmt.kind === "IfStmt") {
      const states: States = {};
      const choices: Branch[] = [];

      let curr: IfStmt | BlockStmt | undefined = stmt;
      while (curr?.kind === "IfStmt") {
        Object.assign(states, this.execute(curr.then));
        choices.push({
          Next: this.getStateName(curr.then.statements[0]),
          ...this.condition(curr.when),
        });
        curr = curr._else;
      }
      return {
        ...states,
        [this.getStateName(stmt)]: {
          Type: "Choice",
          Choices: choices,
          Default:
            curr === undefined
              ? this.next(stmt)
              : // there was an else
                this.getStateName(curr.statements[0]),
        },
      };
    } else if (stmt.kind === "ReturnStmt") {
      return {
        [this.getStateName(stmt)]: this.eval(stmt.expr),
      };
    } else if (stmt.kind === "ThrowStmt") {
      return {
        [this.getStateName(stmt)]: {
          Type: "Pass",
          Next: this.throw(stmt),
        },
      };
    } else if (stmt.kind === "VariableStmt") {
      if (stmt.expr === undefined) {
        return {};
      }
      return {
        [this.getStateName(stmt)]: this.eval(stmt.expr),
      };
    } else if (stmt.kind === "TryStmt") {
      return {
        ...this.execute(stmt.tryBlock),
        ...(stmt.catchClause ? this.execute(stmt.catchClause) : {}),
        ...(stmt.finallyBlock ? this.execute(stmt.finallyBlock) : {}),
      };
    } else if (stmt.kind === "CatchClause") {
      return this.execute(stmt.block);
    } else {
      return assertNever(stmt);
    }

    throw new Error(`cannot convert Statement '${stmt.kind}' to ASL`);
  }

  /**
   * Find the next state that the {@link node} should transition to.
   */
  private next(node: FunctionlessNode | undefined): string {
    if (node === undefined) {
      throw new Error(`Stack Underflow`);
    } else if (isExpr(node)) {
      return this.next(node.parent);
    } else if (isStmt(node)) {
      if (node.kind === "TryStmt" && node.finallyBlock) {
        return this.getStateName(node.finallyBlock.statements[0]);
      } else if (node.kind === "ReturnStmt") {
        return this.return(node);
      } else if (node.next) {
        return this.getStateName(node.next);
      }
    } else if (node.kind === "FunctionDecl") {
      return "Success";
    }
    return this.next(node.parent);
  }

  /**
   * Find the nearest state on the call stack to return the value to.
   */
  private return(node: FunctionlessNode | undefined): string {
    if (node === undefined) {
      throw new Error(`Stack Underflow`);
    } else if (node.kind === "FunctionDecl") {
      return "Success";
    } else if (node.kind === "FunctionExpr") {
      if (!this.returnTransitions.has(node)) {
        throw new Error(`Not Implemented`);
      }
      return this.returnTransitions.get(node)!;
    } else {
      return this.return(node.parent);
    }
  }

  /**
   * Find the nearest state on the call stack to throw an error to.
   */
  private throw(node: FunctionlessNode | undefined): string {
    if (node === undefined) {
      throw new Error(`Stack Underflow`);
    } else if (node.kind === "FunctionDecl") {
      return "Throw";
    } else if (node.kind === "FunctionExpr") {
      return this.getThrowTransition(node);
    } else if (node.kind === "TryStmt") {
      if (node.catchClause) {
        return this.next(node.catchClause);
      } else if (node.finallyBlock) {
        return this.next(node.finallyBlock);
      } else {
        return this.throw(node.parent);
      }
    } else {
      return this.throw(node.parent);
    }
  }

  private getThrowTransition(node: FunctionDecl | FunctionExpr) {
    if (!this.throwTransitions.has(node)) {
      throw new Error(`not implemented`);
    }
    return this.throwTransitions.get(node)!;
  }

  private getStateName(stmt: Stmt): string {
    const name = this.stateTransitions.get(stmt);
    if (name === undefined) {
      throw new Error(``);
    }
    return name;
  }

  public call(call: CallExpr) {
    const serviceCall = findFunction(call);
    if (serviceCall) {
      const task: Task = serviceCall(call, this);

      return {
        ...task,
        ResultPath:
          call.parent?.kind === "VariableStmt"
            ? `$.${call.parent.name}`
            : call.parent?.kind === "ReturnStmt"
            ? "$"
            : JsonPath.DISCARD,
        Catch: [
          {
            // https://docs.aws.amazon.com/step-functions/latest/dg/concepts-error-handling.html
            ErrorEquals: ["States.All"],
            Next: this.throw(call),
          },
        ],
        Next: this.next(call),
      };
    }
    throw new Error(`call must be a service call, ${call}`);
  }

  public eval(expr: Expr): State {
    if (expr.kind === "CallExpr") {
      const serviceCall = findFunction(expr);
      if (serviceCall) {
        const task: Task = serviceCall(expr, this);

        return {
          ...task,
          ResultPath:
            expr.parent?.kind === "VariableStmt"
              ? `$.${expr.parent.name}`
              : expr.parent?.kind === "ReturnStmt"
              ? "$"
              : JsonPath.DISCARD,
          Catch: [
            {
              // https://docs.aws.amazon.com/step-functions/latest/dg/concepts-error-handling.html
              ErrorEquals: ["States.All"],
              Next: this.throw(expr),
            },
          ],
          Next: this.next(expr),
        };
      }
      throw new Error(`call must be a service call, ${expr}`);
    } else if (
      expr.kind === "Identifier" ||
      expr.kind === "PropAccessExpr" ||
      expr.kind === "ElementAccessExpr" ||
      isLiteralExpr(expr)
    ) {
      return {
        Type: "Pass",
        Next: this.next(expr),
        Parameters: {
          [`result${isLiteralExpr(expr) ? "" : ".$"}`]: this.evalJson(expr),
        },
        OutputPath: "$.result",
      };
    } else {
      throw new Error(`cannot eval expression kind '${expr.kind}'`);
    }
  }

  public evalJson(expr: Expr): any {
    if (expr.kind === "Identifier") {
      return `$.${expr.name}`;
    } else if (expr.kind === "PropAccessExpr") {
      return `${this.evalJson(expr.expr)}.${expr.name}`;
    } else if (
      expr.kind === "ElementAccessExpr" &&
      expr.element.kind === "NumberLiteralExpr"
    ) {
      return `${this.evalJson(expr.expr)}[${expr.element.value}]`;
    } else if (expr.kind === "ArrayLiteralExpr") {
      return expr.items.map(this.evalJson);
    } else if (expr.kind === "ObjectLiteralExpr") {
      const payload: any = {};
      for (const prop of expr.properties) {
        if (prop.kind !== "PropAssignExpr") {
          throw new Error(
            `${prop.kind} is not supported in Amazon States Language`
          );
        }
        if (
          prop.name.kind !== "StringLiteralExpr" &&
          prop.name.kind !== "Identifier"
        ) {
          throw new Error(
            `computed name of PropAssignExpr is not supported in Amazon States Language`
          );
        }

        payload[
          `${
            prop.name.kind === "StringLiteralExpr"
              ? prop.name.value
              : prop.name.name
          }${
            isLiteralExpr(prop.expr) || isReferenceExpr(prop.expr) ? "" : ".$"
          }`
        ] = this.evalJson(prop.expr);
      }
      return payload;
    } else if (isLiteralExpr(expr)) {
      return expr.value;
    } else if (expr.kind === "ReferenceExpr") {
      const ref = expr.ref();
      if (ref.kind === "Function") {
        return ref.resource.functionArn;
      } else if (ref.kind === "StepFunction") {
        return ref.stateMachineArn;
      } else if (ref.kind === "Table") {
        return ref.resource.tableName;
      }
    }
    throw new Error(`cannot evaluate ${expr.kind} to JSON`);
  }

  public condition(expr: Expr): Condition {
    if (expr.kind === "UnaryExpr") {
      return {
        Not: this.condition(expr.expr),
      };
    } else if (expr.kind === "BinaryExpr") {
      if (expr.op === "&&") {
        return {
          And: [this.condition(expr.left), this.condition(expr.right)],
        };
      } else if (expr.op === "||") {
        return {
          Or: [this.condition(expr.left), this.condition(expr.right)],
        };
      } else if (expr.op === "+" || expr.op === "-") {
      } else {
        if (isLiteralExpr(expr.left) && isLiteralExpr(expr.right)) {
        } else if (isLiteralExpr(expr.left) || isLiteralExpr(expr.right)) {
          const [lit, val] = isLiteralExpr(expr.left)
            ? [expr.left, expr.right]
            : [expr.right, expr.left];

          if (lit.kind === "NullLiteralExpr") {
            if (expr.op === "!=") {
              return {
                And: [
                  {
                    Variable: this.evalJsonPath(val),
                    IsPresent: true,
                  },
                  {
                    Variable: this.evalJsonPath(val),
                    IsNull: false,
                  },
                ],
              };
            } else if (expr.op === "==") {
              return {
                Or: [
                  {
                    Variable: this.evalJsonPath(val),
                    IsPresent: false,
                  },
                  {
                    Variable: this.evalJsonPath(val),
                    IsNull: true,
                  },
                ],
              };
            }
          } else if (lit.kind === "StringLiteralExpr") {
            const [variable, value] = [
              this.evalJsonPath(val),
              lit.value,
            ] as const;
            if (expr.op === "==") {
              return {
                Variable: variable,
                StringEquals: value,
              };
            } else if (expr.op === "!=") {
              return {
                Not: {
                  Variable: variable,
                  StringEquals: value,
                },
              };
            } else if (expr.op === "<") {
              return {
                Variable: variable,
                StringLessThan: value,
              };
            } else if (expr.op === "<=") {
              return {
                Variable: variable,
                StringLessThanEquals: value,
              };
            } else if (expr.op === ">") {
              return {
                Variable: variable,
                StringGreaterThan: value,
              };
            } else if (expr.op === ">=") {
              return {
                Variable: variable,
                StringGreaterThanEquals: value,
              };
            }
          } else if (lit.kind === "NumberLiteralExpr") {
            const [variable, value] = [
              this.evalJsonPath(val),
              lit.value,
            ] as const;
            if (expr.op === "==") {
              return {
                Variable: variable,
                NumericEquals: value,
              };
            } else if (expr.op === "!=") {
              return {
                Not: {
                  Variable: variable,
                  NumericEquals: value,
                },
              };
            } else if (expr.op === "<") {
              return {
                Variable: variable,
                NumericLessThan: value,
              };
            } else if (expr.op === "<=") {
              return {
                Variable: variable,
                NumericLessThanEquals: value,
              };
            } else if (expr.op === ">") {
              return {
                Variable: variable,
                NumericGreaterThan: value,
              };
            } else if (expr.op === ">=") {
              return {
                Variable: variable,
                NumericGreaterThanEquals: value,
              };
            }
          }
        }
        if (
          expr.left.kind === "StringLiteralExpr" ||
          expr.right.kind === "StringLiteralExpr"
        ) {
        }
        // need typing information
        // return aws_stepfunctions.Condition.str
      }
    }
    debugger;
    throw new Error(`cannot evaluate expression: '${expr.kind}`);
  }

  public evalJsonPath(expr: Expr): string {
    if (expr.kind === "ArrayLiteralExpr") {
      return aws_stepfunctions.JsonPath.array(
        ...expr.items.map((item) => this.evalJsonPath(item))
      );
    } else if (expr.kind === "Identifier") {
      const ref = lookupIdentifier(expr);
      if (
        ref?.kind === "ParameterDecl" &&
        ref.parent?.kind === "FunctionExpr"
      ) {
        // this is a nested FunctionExpr, such as in list.map.
        return `$$.Map.Item.Value`;
      }
      return `$.${expr.name}`;
    } else if (expr.kind === "PropAccessExpr") {
      return `${this.evalJsonPath(expr.expr)}.${expr.name}`;
    } else if (expr.kind === "ElementAccessExpr") {
      return `${this.evalJsonPath(expr.expr)}[${this.evalElement(
        expr.element
      )}]`;
    }

    debugger;
    throw new Error(
      `expression kind '${expr.kind}' cannot be evaluated to a JSON Path expression.`
    );
  }

  private evalElement(expr: Expr): string {
    if (expr.kind === "StringLiteralExpr") {
      return `'${expr.value}'`;
    } else if (expr.kind === "NumberLiteralExpr") {
      return expr.value.toString(10);
    }

    debugger;
    throw new Error(
      `Expression kind '${expr.kind}' is not allowed as an element in a Step Function`
    );
  }
}
